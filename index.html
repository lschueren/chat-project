<!DOCTYPE html>
<html>
<head>
    <title>Cursor MMO</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
        }
        canvas {
            background-color: white;
            border: 1px solid black;
        }
        #coordinates, #connectedClients {
            margin-top: 10px;
            font-family: Arial, sans-serif;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <canvas id="canvas" width="500" height="500"></canvas>
    <div id="coordinates">Cursor Coordinates: (0, 0)</div>
    <div id="connectedClients">Connected Clients: 0</div>
    <script>
        const socket = new WebSocket('ws://' + window.location.host + '/ws');
        let grid = Array.from({ length: 50 }, () => Array(50).fill(null));
        let x = 0;
        let y = 0;
        let color = 'red';
        let cursors = {};
        let currentTextColor = 'black'; // Add this with other global variables at the top

        // Add viewport variables
        let viewportX = 0;
        let viewportY = 0;
        const viewportSize = 50;
        const scrollMargin = 10;

        socket.onopen = function() {
            console.log("WebSocket connection established");
        };

        socket.onerror = function(error) {
            console.log("WebSocket error:", error);
        };

        socket.onmessage = function(event) {
            const message = JSON.parse(event.data);
            grid = message.grid || grid;
            cursors = message.cursors || cursors;
            document.getElementById('connectedClients').textContent = "Connected Clients: " + (message.connectedClients || 0);
            
            if (message.bomb) {
                triggerBombAnimation(message.bomb.color);
            } else if (message.textColor !== undefined) {
                currentTextColor = message.textColor;
                draw();
            } else {
                draw();
            }
        };

        function triggerBombAnimation(color) {
            currentTextColor = color;
            draw();
            setTimeout(() => {
                grid = Array.from({ length: 50 }, () => Array(50).fill(null));
                currentTextColor = 'black';
                draw();
                // Send the cleared grid and color reset to the server
                socket.send(JSON.stringify({ 
                    grid, 
                    x, 
                    y, 
                    color,
                    textColor: 'black'
                }));
            }, 1000);
        }

        document.addEventListener('DOMContentLoaded', (event) => {
            const coordinatesDiv = document.getElementById('coordinates');

            function startMoving(direction) {
                if (moveInterval) clearInterval(moveInterval);
                
                moveInterval = setInterval(() => {
                    let moved = false;
                    
                    switch(direction) {
                        case "ArrowUp":
                            if (y > 0) { y--; moved = true; }
                            break;
                        case "ArrowDown":
                            if (y < 999) { y++; moved = true; }
                            break;
                        case "ArrowLeft":
                            if (x > 0) { x--; moved = true; }
                            break;
                        case "ArrowRight":
                            if (x < 999) { x++; moved = true; }
                            break;
                    }
                    
                    if (moved) {
                        updateViewport();
                        socket.send(JSON.stringify({ grid, x, y, color }));
                    }
                }, speed);
            }

            // Event listeners with debouncing
            let keyTimeout;
            document.addEventListener('keydown', (event) => {
                if (keyTimeout) return;
                
                keyTimeout = setTimeout(() => {
                    keyTimeout = null;
                }, 16);

                if (event.key.length === 1) {
                    grid[x][y] = event.key;
                    x = Math.min(999, x + 1);
                    socket.send(JSON.stringify({ grid, x, y, color }));
                } else if (event.key === "Backspace") {
                    if (x > 0) {
                        x = Math.max(0, x - 1);
                        grid[x][y] = null;
                        socket.send(JSON.stringify({ grid, x, y, color }));
                    }
                } else if (event.key.startsWith("Arrow") && event.key !== currentDirection) {
                    currentDirection = event.key;
                    startMoving(event.key);
                }
            });

            document.addEventListener('keyup', (event) => {
                if (event.key === currentDirection) {
                    clearInterval(moveInterval);
                    currentDirection = null;
                }
            });

            // Start game loop
            animationFrameId = requestAnimationFrame(draw);

            // Cleanup on page unload
            window.addEventListener('unload', () => {
                cancelAnimationFrame(animationFrameId);
                clearInterval(moveInterval);
            });
        });

        // Use RequestAnimationFrame for smooth animation
        let animationFrameId;
        const FPS = 60;
        const frameDelay = 1000 / FPS;
        let lastFrameTime = 0;

        // Viewport settings
        const squareSize = 10;

        // Movement state
        let moveInterval;
        let currentDirection = null;
        const speed = 16; // ~60fps

        // Canvas context (store reference)
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { alpha: false }); // Disable alpha for better performance
        ctx.font = '10px monospace';

        function updateViewport() {
            // Horizontal scrolling with bounds checking
            if (x >= viewportX + viewportSize - scrollMargin) {
                viewportX = Math.min(x - viewportSize + scrollMargin + 1, 1000 - viewportSize);
            } else if (x <= viewportX + scrollMargin) {
                viewportX = Math.max(x - scrollMargin - 1, 0);
            }

            // Vertical scrolling with bounds checking
            if (y >= viewportY + viewportSize - scrollMargin) {
                viewportY = Math.min(y - viewportSize + scrollMargin + 1, 1000 - viewportSize);
            } else if (y <= viewportY + scrollMargin) {
                viewportY = Math.max(y - scrollMargin - 1, 0);
            }
        }

        // Constants for performance
        const SPEED = 8;  // Reduced from 16 to 8ms for faster cursor response
        const FPS = 60;
        const frameDelay = 1000 / FPS;

        // Canvas setup with white background
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        ctx.font = '10px monospace';
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        function draw(timestamp) {
            if (timestamp - lastFrameTime < frameDelay) {
                requestAnimationFrame(draw);
                return;
            }
            lastFrameTime = timestamp;

            // Clear with white background
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid content more efficiently
            ctx.fillStyle = currentTextColor;
            const endX = Math.min(viewportX + viewportSize, 1000);
            const endY = Math.min(viewportY + viewportSize, 1000);
            
            for (let i = viewportX; i < endX; i++) {
                for (let j = viewportY; j < endY; j++) {
                    if (grid[i] && grid[i][j]) {
                        ctx.fillText(grid[i][j], 
                            (i - viewportX) * squareSize, 
                            (j - viewportY) * squareSize + 10);
                    }
                }
            }
            
            // Draw cursors
            for (const key in cursors) {
                const cursor = cursors[key];
                const relativeX = cursor.x - viewportX;
                const relativeY = cursor.y - viewportY;
                
                if (relativeX >= 0 && relativeX < viewportSize && 
                    relativeY >= 0 && relativeY < viewportSize) {
                    ctx.fillStyle = cursor.color;
                    ctx.fillRect(
                        relativeX * squareSize, 
                        relativeY * squareSize, 
                        squareSize, 
                        squareSize
                    );
                }
            }
            requestAnimationFrame(draw);
        }

        // Optimize movement handling
        function startMoving(direction) {
            if (moveInterval) clearInterval(moveInterval);
            
            const move = () => {
                let moved = false;
                switch(direction) {
                    case "ArrowUp":
                        if (y > 0) { y--; moved = true; }
                        break;
                    case "ArrowDown":
                        if (y < 999) { y++; moved = true; }
                        break;
                    case "ArrowLeft":
                        if (x > 0) { x--; moved = true; }
                        break;
                    case "ArrowRight":
                        if (x < 999) { x++; moved = true; }
                        break;
                }
                
                if (moved) {
                    updateViewport();
                    socket.send(JSON.stringify({ grid, x, y, color }));
                }
            };

            move(); // Execute immediately
            moveInterval = setInterval(move, SPEED); // Then start interval
        }
    </script>
</body>
</html>